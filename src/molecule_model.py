import torch
import torch.nn as nn
from torch.nn import functional as F
from torchtyping import TensorType


class CAlphaModel(nn.Module):
    """
    This molecule model only models the C-alpha atoms of the protein; all other atoms are neglected.

    Given a base conformation of all C-alpha atoms and 3D translation vectors for each, this class deforms (i.e. translates) the atoms as specified by the deformation vectors.
    """

    def __init__(
        self,
        prior_conf: TensorType["n_residues", 3],
        res_names: list,  # len [n_residues]
        n_res_total: int,
    ):
        """
        prior_conf - 3d point cloud representation of the prior conformation of the molecule (with residues as pseudoatoms)

        n_res_total - the total number of residues in the protein complex, including residues that are not modelled and are therefore not present in the prior conformation. This is the number that can be found on the pdb site under "Deposited Residue Count".
        """
        super().__init__()

        self.res_names = res_names

        # this is the fraction of all residues in the protein complex that are present in the prior conformation. This is often less than 1, because not all residues are modelled in the PDB entry. We correct stds and densities by this number.
        self.model_fraction = len(res_names) / n_res_total

        # subtract the centroid (= mean residue position) to center the structure
        prior_conf = prior_conf - prior_conf.mean(dim=0, keepdim=True)

        # register as buffers all tensors that need to be on the same device as the model's parameters
        self.register_buffer("prior_conf", prior_conf)

    @property
    def stds(self) -> TensorType["n_residues"]:
        """
        Returns the standard deviations (in units of Angstrom) of the Gaussian pdf with which each atom should be projected by the EM simulator. The optimal stds were computed by a separate script, and are equal to the std of the best Gaussian fit to the expected value of the projection of each residue.
        """

        # these values are the result of computing the best Gaussian fit to the expected projection (over 100k projections) of each amino acid
        best_stds = {
            "MET": 1.85,
            "ARG": 2.15,
            "ILE": 1.6,
            "LEU": 1.65,
            "GLY": 1.4,
            "ALA": 1.4,
            "PRO": 1.5,
            "LYS": 1.85,
            "THR": 1.55,
            "GLN": 1.85,
            "PHE": 1.95,
            "GLU": 1.9,
            "TYR": 2.1,
            "SER": 1.45,
            "ASP": 1.7,
            "VAL": 1.5,
            "CYS": 1.6,
            "CYM": 1.6,
            "ASN": 1.65,
            "HIS": 1.9,
            "TRP": 2.15,
        }

        # map each residue to its best std
        stds = [best_stds[name] for name in self.res_names]
        stds = torch.tensor(stds) / self.model_fraction

        return stds

    @property
    def densities(self) -> TensorType["n_residues"]:
        """
        Returns the number of electrons in each residue. The EM simulator should project each residue with Gaussian pdfs with a mass (=2d integral) equal to these densities.
        """

        electrons_per_residue = {
            "ARG": 85,
            "ILE": 62,
            "LEU": 62,
            "GLY": 30,
            "ALA": 38,
            "PRO": 52,
            "LYS": 71,
            "THR": 54,
            "GLN": 68,
            "PHE": 78,
            "MET": 70,
            "GLU": 67,
            "TYR": 86,
            "SER": 46,
            "ASP": 59,
            "VAL": 54,
            "CYS": 54,
            "CYM": 54,
            "ASN": 60,
            "HIS": 72,
            "TRP": 98,
        }

        # map each residue to its number of electrons
        densities = [electrons_per_residue[name] for name in self.res_names]
        densities = torch.tensor(densities, dtype=torch.float) / self.model_fraction

        return densities

    def forward(
        self, x: TensorType["B", "n_residues", 3]
    ) -> TensorType["B", "n_residues", 3]:
        # unsqueeze a batch dimension to the prior and apply the translations
        new_conf = self.prior_conf.unsqueeze(0) + x

        return new_conf

    @property
    def prior(self) -> TensorType["n_residues", 3]:
        """
        Returns the prior conformation
        """
        return self.prior_conf

    def dcc(self, conf: TensorType["B", "n_residues", 3]):
        """
        Given a conformation generated by this class, this function returns the DCCs (= Distance between Consecutive C-alpha atoms).
        """

        # dcc_vectors[:, i] is equal to the displacement vector between the C-alpha of residue i and residue i+1
        dcc_vectors = torch.diff(conf, dim=1)
        # shape [B, n_residues - 1, 3]

        # compute norm of all displacement vectors
        dcc_lengths = torch.linalg.vector_norm(dcc_vectors, dim=2)
        # shape [B, n_residues - 1]

        return dcc_lengths
