from torch.utils.data import Dataset, Subset
import os
import torch
from scipy.spatial.transform import Rotation as R
import mdtraj
from utils import distribute_uniformly


class CovDataset(Dataset):
    def __init__(
        self,
        root_dir: str,
        dose: int,
        prior_idx=0,
    ):
        """
        This is a dataset with an (almost but not exactly) uniform distribution over the 200 conformation states of the MD simulated Sars-Cov protein (also referred to as Nsp13). All states have approximately 595 particle images.

        The distribution is not exactly uniform because particles close to the edge of the micrograph were discarded, and some micrographs (generated by Parakeet) contained more of those than other. However, the distribution is close enough to uniform to be treated as such.

        root_dir - path to the data folder
        dose - the electron dose

        root_dir/
        ├─ cov_heterogeneous/
        │  ├─ picked_particles_{dose}e.pickle
        """
        super().__init__()
        self.root_dir = root_dir
        self.dose = dose

        # the data was generated with these settings
        self.side_len = 110
        self.defocus = torch.tensor(20000.0, dtype=torch.float)
        self.astigm_angle = torch.tensor(0.0, dtype=torch.float)
        self.resolution = 1
        self.accelerating_voltage = 300
        self.spherical_aberration = 2.7

        # Parakeet has no setting for amplitude contrast, so we use the same small value as Rosenbaum
        self.amplitude_contrast = 0.06

        md_data = self.load_conformations()

        self.res_names = md_data["res_names"]
        self.prior_conf = md_data["confs"][prior_idx].to(torch.float)
        self.gt_confs = md_data["confs"].to(torch.float)

        self.load_dataset()

        # assert that all dataset tensors have the same length
        assert self.img.shape[0] == self.pose.shape[0]

    def __getitem__(self, index):
        """
        Returns a dict with the following keys and shapes (all tensors):
            - "img" [side_len, side_len] - the projection
            - "idx" torch.long - the index of this element in the dataset; equal to argument 'index'
            - "conf_idx" torch.long - the index of the ground truth conformation
            - "defocus_u" torch.float - CTF variable
            - "defocus_v" torch.float - CTF variable
            - "astigm_angle" torch.float - CTF variable
            - "pose" [3, 3] - rotation matrix with the pose of the molecule

        The images are already z-standardized and the particles are centered.
        """
        return {
            "idx": index,
            "conf_idx": self.conf_idx[index],
            "img": self.img[index],
            "pose": self.pose[index],
            "defocus_u": self.defocus,
            "defocus_v": self.defocus,
            "astigm_angle": self.astigm_angle,
        }

    def __len__(self):
        return self.img.shape[0]

    def load_dataset(self):
        """
        Loads the dataset directly from disk if it was already processed, and otherwise builds this dataset by loading all particle micrographs and related data from disk.
        """

        assert os.path.isdir(self.root_dir)

        file_path = os.path.join(
            self.root_dir, "cov_heterogeneous", f"picked_particles_{self.dose}e.pickle"
        )

        # load the dataset
        particles = torch.load(file_path)

        imgs = particles["imgs"].to(torch.float)
        # normalize images
        self.img = (imgs - imgs.mean()) / imgs.std()

        # Parakeet uses "axis–angle representation" for orientations. See https://github.com/rosalindfranklininstitute/parakeet/blob/b1faf5eed805cdb2b472400989737b6b63d5e062/src/parakeet/scan.py#L211C1-L211C1
        rot_mat = R.from_rotvec(particles["poses"]).as_matrix()
        self.pose = torch.from_numpy(rot_mat).to(torch.float)

        self.conf_idx = particles["conf_id"].to(torch.long)

    def validation_subset(self, val_size):
        """
        Returns a subset of the dataset of size val_size. A uniform distribution over the conformation is assumed. That is, each conformation occurs val_size/n_conf times in the validation set.
        """

        n_conf = 200

        # This is a map from conf_idx to the number of examples the val set must contain of that conf.
        # I.e. n_per_conf[2] returns the number of examples of conformation 2.
        n_per_conf = distribute_uniformly(n=val_size, n_bins=n_conf)

        # count the number of already added examples per conf in this dict
        counter = {conf_idx: 0 for conf_idx in range(n_conf)}

        # loop through the dataset and add examples of each conformation to the validation set
        val_set = []
        for el in self:
            conf_idx = int(el["conf_idx"])

            if counter[conf_idx] < n_per_conf[conf_idx]:
                val_set.append(el)
                counter[conf_idx] += 1

        return val_set

    def load_conformations(self):
        """
        Loads all MD simulated conformations from file into a tensor. All non-hydrogen atoms are removed. Relevant auxiliary tensors are also returned, in particular c_alpha_idx and res_idx.
        """

        trajectory_path = os.path.join(self.root_dir, "cov_md", "MDtraj_sarscov_2.dcd")
        topology_path = os.path.join(
            self.root_dir,
            "cov_md",
            "DESRES-Trajectory_sarscov2-12212688-5-2-no-water.pdb",
        )

        assert os.path.isfile(trajectory_path)
        assert os.path.isfile(topology_path)

        t = mdtraj.load(trajectory_path, top=topology_path)

        # The sars-cov pdb contains some ligands and other non-amino-acid particles. We only keep the amino acids in the model. CYM is a modified CYS amino acid with one H atom removed. For our means and purposes CYS and CYM are synonyms
        amino_acids = [
            "MET",
            "ARG",
            "ILE",
            "LEU",
            "GLY",
            "ALA",
            "PRO",
            "LYS",
            "THR",
            "GLN",
            "PHE",
            "GLU",
            "TYR",
            "SER",
            "ASP",
            "VAL",
            "CYS",
            "ASN",
            "HIS",
            "TRP",
            "CYM",
        ]

        # extract the atom indices of all atoms belonging to amino acids
        x = [a.index for a in t.topology.atoms if a.residue.name in amino_acids]

        # keep only the atoms belonging to amino acids
        t = t.atom_slice(x)

        # multiply coordinates by 10 to convert units to Angstrom
        conformations = torch.tensor(t.xyz) * 10
        # conformations has shape [200, n_atoms, 3] containing the coordinates of all atoms in all 200 conformations

        # list that maps the residue index to the name of the amino acid
        res_names = [a.residue.name for a in t.topology.atoms if a.name == "CA"]

        # True iff the atom at that index is a C-alpha atom
        is_c_alpha = torch.tensor([a.name == "CA" for a in t.topology.atoms])
        c_alpha_idx = torch.where(is_c_alpha)[0]

        # keep only the C-alpha atoms of the conformations
        confs = conformations[:, c_alpha_idx]

        # center all conformations by subtracting the centroid (=mean point)
        confs = confs - confs.mean(dim=1, keepdim=True)

        # conformations shape [200, n_residues, 3] (200 being the total number of MD-simulated conformations)
        # res_names is a list with len n_residues
        return {
            "confs": confs,
            "res_names": res_names,
        }
